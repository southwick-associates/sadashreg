---
title: "Make dashboard tables for Tableau Input (by priv)"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
output: 
    html_document:
        toc: true
        toc_float: true
        code_folding: hide
params:
    state: OR
    priv_nm: sports # (fish, hunt, all_sports) or (deer, trout, etc.)
    priv_ref: NONE  # (NONE, fish, hunt, all_sports) > denominator for privilege rate
    yrs: 2008:2017  # (first_year:last_year)
    res_type: NONE # (NONE, res, nonres)
    res_filter: NONE # (NONE, res, nonres)
    quarter: 4 # quarter to be estimated
    out_dir: "../../data/dashboard-results"  # directory for output RData
---

## Overview

This was modified to (in theory) be more generic with regard to choice of state. Only tested with OR as of 12-17-28


```{r setup, message=FALSE}
library(tidyverse)
library(stringr)
library(salic)
source("func.R")
options(scipen = 999)
knitr::opts_chunk$set(comment = NA)

```

## Params

```{r}
# make a vector of years from the params$yrs input
get_range <- function(x) {
    y <- stringr::str_split_fixed(x, ":", 2)
    `:`(y[1], y[2])
}
yrs <- get_range(params$yrs)
```

```{r}
tribble(
    ~param, ~value,
    "priv_nm", params$priv_nm,
    "priv_ref", params$priv_ref,
    "yrs", params$yrs,
    "res_type", params$res_type,
    "res_filter", params$res_filter,
    "quarter", params$quarter,
    "current_quarter", params$current_quarter,
    "out_dir", params$out_dir
) %>% DT::datatable()
```

## Load

### Population

*For estimating participation rates*

```{r}
f <- "E:/SA/Data-production/Data-Dashboards/_Shared/census.sqlite3"
db_census <- src_sqlite(f)

pop_county <- tbl(db_census, "pop_acs") %>% 
    filter(state_abbrev == params$state) %>%
    collect() %>%
    # collapse to 7 age categories
    group_by(county_fips, year, sex, age) %>%
    summarise(pop = sum(pop)) %>%
    ungroup()

# naive forecast to current year (usually needed for quarterly results)
last_year_pop <- max(unique(pop_county$year))
yrs_missing <- setdiff(yrs, unique(pop_county$year))
if (length(yrs_missing > 0)) {
    pop_state <- group_by(pop_county, year) %>% 
        summarise(pop = sum(pop)) %>%
        mutate(pct_change = pop / lag(pop))
    avg_increase <- mean(pop_state$pct_change, na.rm = TRUE)
    
    # produce future year estimates
    # it's probably a bad idea to use this method for more than 1 year in the future
    pop_county_future <- filter(pop_county, year == last_year_pop) %>%
            mutate(year = year + 1, pop = pop * avg_increase)
    pop_county <- bind_rows(pop_county, pop_county_future)
    rm(pop_county_future)
    count(pop_county, year) %>% tail()
}

# join county names
county_fips <- tbl(db_census, "county_fips") %>%
    select(county_fips, county = county_name) %>%
    collect()
pop_county <- pop_county %>%
    left_join(county_fips, by = "county_fips")
glimpse(pop_county)
```

### Permissions

```{r}
f <- paste0("E:/SA/Data-production/Data-Dashboards/", params$state, "/license.sqlite3")
db_license <- src_sqlite(f)

# temporarily pull customers for joining customer info
cust <- tbl(db_license, "cust") %>%
    select(cust_id, county_fips, sex, birth_year) %>%
    collect() %>%
    left_join(county_fips, by = "county_fips")

# pull permissions from license history
f <- paste0("E:/SA/Data-production/Data-Dashboards/", params$state, "/history.sqlite3")
db_history <- src_sqlite(f)

priv <- tbl(db_history, params$priv_nm) %>% 
    select(cust_id, year, res, lapse, R3) %>%
    collect() %>%
    filter(year %in% yrs) %>%
    left_join(cust, by = "cust_id")
rm(cust, county_fips)
glimpse(priv)
```


## Prep

### Calculate Age Categories 

```{r}
priv <- salic::recode_agecat(priv)
sample_n(priv, 10) %>% select(year, birth_year, age_year, age, agecat) %>% data.frame()
```


### Label Demographic Categories

*So the output will show category names instead of codes*

```{r}
priv <- select(priv, -birth_year, -age_year, -age) %>%
    rename(age = agecat) %>%
    df_factor_sex() %>%
    df_factor_res() %>%
    df_factor_R3()

pop_county <- pop_county %>%
    df_factor_sex() %>%
    df_factor_age()
```


### Filter Age

Excluding youths and seniors

```{r}
drop_ages <- c("0-17", "65+")
pop_county <- pop_county %>%
    filter(!age %in% drop_ages)

priv <- priv %>%
    filter(!age %in% drop_ages)
```


## Results

### Population

```{r}
pop <- list()

pop[["tot"]] <- group_by(pop_county, year) %>%
    summarise(pop = sum(pop)) 

pop[["sex"]] <- group_by(pop_county, year, sex) %>%
    summarise(pop = sum(pop)) %>% ungroup() %>%
    format_grp("gender", "sex")

pop[["age"]] <- group_by(pop_county, year, age) %>%
    summarise(pop = sum(pop)) %>% ungroup() %>%
    format_grp("age")

pop[["county"]] <- group_by(pop_county, year, county) %>%
    summarise(pop = sum(pop)) %>% ungroup() %>%
    format_grp("county")

rm(pop_county)
```

### Participants

- Do some work on checking and visualization
    + checking > see est_total_check() and notes below
    + visualization > include an interactive ggplot showing trends (like dashboard)
    + (see WI dive code in producing a nice faceted line plot)
    + (use group: [tot, sex, ...] & compare: [down, across] for widgets)

- Future: Maybe include a warning based on pct_diff threshold
    + also a count of missing values would be useful (shows something similar), but a more direct measurement of the amount of estimation needed

```{r}
# total counts - used for correcting for missing values in grouping variables
tot <- count(priv, year)
tot_residency <- count(priv, year, res) %>%
    group_by(year) %>%
    est_total("res", tot)

part <- list()
part[["tot"]] <- format_metric(tot) %>% 
    mutate(segment = "All", category = "All")

part[["sex"]] <- count(priv, year, sex) %>%
    group_by(year) %>%
    est_total("sex", tot) %>% 
    format_metric() %>% format_grp("gender", "sex")

part[["age"]] <- count(priv, year, age) %>%
    group_by(year) %>%
    est_total("age", tot) %>%
    format_metric() %>% format_grp("age")

part[["res"]] <- format_metric(tot_residency) %>% 
    format_grp("Residency", "res")
```

```{r}
### Residents Only (for by-county breakouts & participation rates)
if (params$res_type != "nonres" & params$res_filter != "nonres") {
    priv_res <- filter(priv, res == "Resident")
    tot_res <- filter(tot_residency, res == "Resident") %>% select(-n.x)
    
    part_res <- list()
    part_res[["county"]] <- priv_res %>%
        filter(year %in% c(yrs[length(yrs)])) %>%
        count(year, county) %>%
        group_by(year) %>%
        est_total("county", tot_res) %>%
        format_metric() %>% format_grp("county")
    
    # age & sex - for calculating participation rates
    # these won't be included in final dashboard table
    part_res[["sex"]] <- count(priv_res, year, sex) %>%
        group_by(year) %>%
        est_total("sex", tot_res) %>% 
        format_metric() %>% format_grp("gender", "sex")
    
    part_res[["age"]] <- count(priv_res, year, age) %>%
        group_by(year) %>%
        est_total("age", tot_res) %>%
        format_metric() %>% format_grp("age")
    
    # stack for dashboard
    part_tbl <- bind_rows(part) %>% bind_rows(part_res[["county"]]) %>%
        # round participants to nearest whole number, since fractions don't make sense
        mutate(value = round(value, digits = 0))
    rm(tot, tot_res, tot_residency)
    
    # check percent missing
    # to insure nothing odd in estimating total for groups
    # bind_rows(part_tbl, part_res[["sex"]]) %>% bind_rows(part_res[["age"]]) %>%
    #     est_total_check() %>% DT::datatable()
} else {
    part_tbl <- bind_rows(part)
}
```

### Participation Rate

- Participants / Resident Population
- Only estimated for overall types (priv_ref == NONE)

```{r}
if (params$priv_ref == "NONE" & params$res_filter != "nonres") {
    rate <- list()
    
    # overall permissions
    rate[["sex"]] <- part_res[["sex"]] %>%
        select(year, segment, category, part = value) %>%
        left_join(pop[["sex"]], by = c("year", "segment", "category")) %>%
        mutate(value = part / pop, metric = "participation rate")
    
    rate[["age"]] <- part_res[["age"]] %>%
        select(year, segment, category, part = value) %>%
        left_join(pop[["age"]], by = c("year", "segment", "category")) %>%
        mutate(value = part / pop, metric = "participation rate")
    
    rate[["county"]] <- part_res[["county"]] %>%
        select(year, segment, category, part = value) %>%
        left_join(pop[["county"]], by = c("year", "segment", "category")) %>%
        mutate(value = part / pop, metric = "participation rate")
    
    # overall rate is included twice (which is weird, but helps on the tableau end)
    rate[["res"]] <- part[["res"]] %>%
        select(year, segment, category, part = value) %>%
        left_join(pop[["tot"]], by = "year") %>%
        # nonresident is set at zero for tableau dashboard
        mutate(value = part / pop, metric = "participation rate",
               value = ifelse(category == "Nonresident", 0, value))
    
    rate[["tot"]] <- filter(rate[["res"]], category == "Resident") %>%
        select(-segment, -category) %>%
        mutate(segment = "All", "category" = "All")
    
    rate_tbl <- bind_rows(rate)
    group_by(rate_tbl, segment) %>% summarise(max_rate = max(value))
}
```

### Recruits

- Mostly the same as Participation code above, with some differences
    + different `format_metric()`
    + filter: `priv_new` vs. `priv`
    + resident-specific is only needed for counties (since rate is not calculated for these)

```{r}
# check - should only be missing for the first 5 years
count(priv, R3, year) %>% spread(year, n)
priv_new <- filter(priv, !is.na(R3), R3 == "Recruit")

# only run if there are recruits available
run_recruit <- nrow(priv_new) > 0
if (run_recruit) {
    # total counts - used for correcting for missing values in grouping variables
    tot <- count(priv_new, year)
    tot_residency <- count(priv_new, year, res) %>%
        group_by(year) %>%
        est_total("res", tot)
    
    recruit <- list()
    recruit[["tot"]] <- format_metric(tot, "participants - recruited") %>% 
        mutate(segment = "All", category = "All")
    
    recruit[["sex"]] <- count(priv_new, year, sex) %>%
        group_by(year) %>%
        est_total("sex", tot) %>% 
        format_metric("participants - recruited") %>% format_grp("gender", "sex")
    
    recruit[["age"]] <- count(priv_new, year, age) %>%
        group_by(year) %>%
        est_total("age", tot) %>%
        format_metric("participants - recruited") %>% format_grp("age")
    
    recruit[["res"]] <- format_metric(tot_residency, "participants - recruited") %>% 
        format_grp("Residency", "res")
    
    ### Residents Only (for by-county breakouts)
    priv_new_res <- filter(priv_new, res == "Resident")
    tot_res <- filter(tot_residency, res == "Resident") %>% select(-n.x)
    
    if (params$res_type != "nonres" & params$res_filter != "nonres") {
        recruit[["county"]] <- priv_new_res %>%
            filter(year %in% c(yrs[length(yrs)])) %>%
            count(year, county) %>%
            group_by(year) %>%
            est_total("county", tot_res) %>%
            format_metric("participants - recruited") %>% format_grp("county")
    }
    
    # stack
    recruit_tbl <- bind_rows(recruit) %>%
        # round recruiticipants to nearest whole number, since fractions don't make sense
        mutate(value = round(value, digits = 0))
    rm(tot, tot_res, tot_residency, priv_new_res)
    
    # check
    # if (params$res_type != "nonres" & params$res_filter != "nonres") {
    #     est_total_check(recruit_tbl) %>% DT::datatable() # pct missing
    # }
} else {
    recruit_tbl <- data.frame()
}
```

### Churn

```{r}
churn <- list()

churn[["tot"]] <- est_churn(priv) %>% format_metric("churn", "churn") %>% 
    mutate(segment = "All", category = "All")

churn[["sex"]] <- priv %>% est_churn("sex") %>%
    format_metric("churn", "churn") %>% format_grp("gender", "sex")

churn[["age"]] <- priv %>% est_churn("age") %>%
    format_metric("churn", "churn") %>% format_grp("age")

churn[["res"]] <- priv %>% est_churn("res") %>%
    format_metric("churn", "churn") %>% format_grp("Residency", "res")

if (params$res_type != "nonres" & params$res_filter != "nonres") {
    churn[["county"]] <- priv_res %>%
        filter(year %in% c(yrs[length(yrs)-1])) %>%
        est_churn("county") %>%
        format_metric("churn", "churn") %>% format_grp("county")
}
# rm(priv_res)

# stack for dashboard
churn_tbl <- bind_rows(churn)
DT::datatable(churn_tbl)
```

## Save

### Stack for Tableau

```{r}
if (params$res_filter == "nonres") {
    out_tbl <- part_tbl 
} else {
    out_tbl <- bind_rows(part_tbl, rate_tbl)
}
out_tbl <- bind_rows(out_tbl) %>%
    bind_rows(recruit_tbl)
if (params$quarter == 4) out_tbl <- bind_rows(out_tbl, churn_tbl)

type <- params$priv_nm # for allowing assignment to group variable to work correctly
out_tbl <- mutate(out_tbl, quarter = params$quarter, group = type) %>%
    select(quarter, group, metric, segment, year, category, value)

# churn will likely be 10% smaller (except for county)
# recruited will likely be around 50% smaller (5 yrs can't be counted)
count(out_tbl, metric, segment) %>% spread(segment, n)
```

### Save Priv

```{r}
out_nm <- paste(params$state, params$priv_nm, params$quarter, sep = "-")
f <- file.path(params$out_dir, paste0(out_nm, ".RDATA"))
save(out_tbl, file = f) 
glimpse(out_tbl)
```
