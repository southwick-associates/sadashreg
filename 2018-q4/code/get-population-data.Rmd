---
title: "Get ACS Data using Census API with R Package acs"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
output: 
    html_document:
        toc: true
        toc_float: true
        code_folding: show
params:
    lic_yrs: 2009:2018  # years included in license data
    acs_last_yr: 2017
    census_pop1: "D:/SA/data2/_CENSUS_ACS/pop_by_state update/st-est00int-01.xls"
    census_pop2: "D:/SA/data2/_CENSUS_ACS/pop_by_state update/nst-est2016-01.xlsx"
    test: FALSE  # (TRUE, FALSE) > if TRUE, doesn't write output to sqlite
---

```{r setup, message=FALSE}
library(acs)
library(stringr)
library(plyr)
library(tidyverse)
library(readxl)
library(DT)
library(tibble)
source("../../R/acs-pop-functions.R")
knitr::opts_chunk$set(comment = NA)
```

- Can't get data before 2016 from acs? Weird, not going to solve now, but can deal with it once the server is back online


## Params

- This script should require minimal updating:
    + acs_last_yr as more data becomes available in package ACS
    + census_pop2 as more data becomes available in US Census. This needs to be downloaded as an Excel file:
    + https://www2.census.gov/programs-surveys/popest/tables/2010-2016/state/totals/

```{r}
# make a vector of years from the params$yrs input
get_range <- function(x) {
    y <- stringr::str_split_fixed(x, ":", 2)
    `:`(y[1], y[2])
}
lic_yrs <- get_range(params$lic_yrs)
```

## Load Data

### ACS Pop by county by age by sex

```{r}
# check to insure most recent available year is being used (params$acs_last_yr)
# if it shows available tables, then update params$acs_last_yr accordingly
acs.lookup(endyear = params$acs_last_yr+1, table.number = "B01001", span = 5)

# get data for all states
states <- list.files("../out") %>% str_remove(".csv")
dat <- list()
for (i in 2016:params$acs_last_yr) dat[[i]] <- get_acs(i, states) %>% mutate(year = i)
dat <- bind_rows(dat) %>%
    mutate(county = stringr::str_replace(
        county, paste0(" County, ", params$state_name), "")
    )
# count(dat, year)
# count(dat, county) %>% View()
glimpse(dat)
```

### US Census Pop by state

```{r}
pop_state <- get_state_pop(params$census_pop2, 2010:2016)
# get_state_pop_old(params$census_pop1, 2009)
pop_state <- pop_state %>%
    mutate(year = as.numeric(year))

# casting forward or backward, can probably use newer functions
# - a second consideration is pegging to state totals
# - might just need to modify the function for this purpose
```

```{r, eval=FALSE}
# estimate 2017 - assume linear trend
model <- lm(pop_state ~ year, data = pop_state)
est <- predict(model, data.frame(year = lic_yrs))
pop_state <- add_row(pop_state, state = "Georgia", year = 2017, pop_state = est[8])

data.frame(pop_state)
```

```{r}
pop_state
```

### County fips codes

```{r}
data("fips.county", package = "acs")
fips_county <- filter(fips.county, State %in% states) %>%
    mutate(county = stringr::str_replace(County.Name, " County", "")) %>%
    select(state = State, fips = County.ANSI, county) %>%
    left_join(
        data.frame(state = state.abb, state_name = state.name, stringsAsFactors = FALSE)
    )
data.frame(stringsAsFactors = FALSE)
rm(fips.county)
# DT::datatable(fips_county)
```

## County Coverage

- n should be the same for all counties

```{r}
# goddammit, more work is needed
state_names <- state.name[state.abb %in% states]
for (i in state_names) {
    dat <- mutate(dat, county = str_replace(county, i, paste0("\t", i)))
}
dat <- separate(dat, county, c("county", "state_name"), sep = " \t")

# quite a few didn't match (due to city,)
# not entirely sure what to do with those
# also dumb dumb, you don't actually need these data by city, just sex by age
full_join(fips_county, dat, by = c("county", "state_name")) %>%
    count(state, fips, county) %>%
    DT::datatable()
```

## Prep ACS

### Tidy column names

```{r, warning=FALSE}
# a "Too few values" warning is expected since sex & age aren't populated for all var
# it's probably not an indication of a problem
dat_in <- dat

dat <- mutate(dat_in, cat = str_replace(var, "Sex by Age: ", "")) %>%
    tidyr::separate(cat, c("sex", "age"), sep = ": ") %>%
    mutate(
        sex = ifelse(sex == "Total:", "All", str_replace(sex, ":", "")),
        age = ifelse(is.na(age), "All", age)
    )
count(dat, sex, age, var) %>% DT::datatable()
```

### Totals & Pct Change

```{r}
check_pop_totals(dat) # all diff should be zero
pct_change_sex(dat) %>% select(-value) %>% spread(sex, pct_change) %>% data.frame()
pct_change_age(dat) %>% select(-value) %>% spread(year, pct_change) %>% data.frame()
```

### Drop "All" rows

- totals can easily be calculated by grouping, so no need to keep these
- The overall county totals for the most recent year will be kept temporarily for the summary at the end of the script

```{r}
dat_total <- filter(dat, year == params$acs_last_yr, sex == "All", age == "All")
dat <- filter(dat, sex != "All", age != "All") %>%
    select(-var)
glimpse(dat)
```

## Adjust with Census

### Match Totals by Year

- This insures the county totals match the most recent estimates available from the Census

```{r}
# estimate necessary adjustment
adjust <- group_by(dat, year) %>%
    summarise(value = sum(value)) %>%
    left_join(pop_state, by = "year") %>%
    mutate(adjust = pop_state / value)

# apply adjustment across all detailed estimates
dat <- select(adjust, year, adjust) %>%
    full_join(dat, by = "year") %>%
    mutate(value = value * adjust) %>%
    select(-adjust) %>%
    ungroup()

# check
group_by(dat, year) %>%
    summarise(new_value = sum(value)) %>%
    left_join(adjust)
```

### Fill missing years

- for missing years (pre 2009 & post most recent available years)
- populate using population by state

```{r}
# pct <- list()  # distributions
# est <- list()  # estimated populations

# post acs_last_yr > based on acs_last_yr
pct <- filter(dat, year == params$acs_last_yr) %>%
    left_join(pop_state, by = "year") %>%
    mutate(pct = value / pop_state) %>%
    select(-year, -value, -pop_state)

yr1 <- params$acs_last_yr+1
est <- filter(pop_state, year %in% yr1:lic_yrs[length(lic_yrs)]) %>%
    left_join(pct, by = "state") %>%
    mutate(value = pop_state * pct) %>%
    select(-pop_state, -pct, -state)

# combine & check
dat <- bind_rows(dat, est)

group_by(dat, year) %>%
    summarise(value = sum(value)) %>%
    left_join(pop_state)
```

## Final Prep

### Recode variables

- To match the coding format of the state license data
    
```{r}
dat <- dat %>% mutate(
    sex_old = sex,
    sex_label = factor(sex, c("Male", "Female")),
    sex = as.numeric(sex_label)
)
count(dat, sex, sex_label, sex_old) %>% data.frame()
```

```{r}
age_map <- tribble(
    ~lic_age, ~acs_age,
    1,"Under 5 years",
    1,"5 to 9 years",
    1,"10 to 14 years",
    1,"15 to 17 years",
    2,"18 and 19 years",
    2,"20 years",
    2,"21 years",
    2,"22 to 24 years",
    3,"25 to 29 years",
    3,"30 to 34 years",
    4,"35 to 39 years",
    4,"40 to 44 years",
    5,"45 to 49 years",
    5,"50 to 54 years",
    6,"55 to 59 years",
    6,"60 and 61 years",
    6,"62 to 64 years",
    7,"65 and 66 years",
    7,"67 to 69 years",
    7,"70 to 74 years",
    7,"75 to 79 years",
    7,"80 to 84 years",
    7,"85 years and over"
)
dat_tmp <- dat
dat <- dat %>% mutate(
    age_acs = age,
    age_acs_ordered = factor(age, levels = age_map$acs_age),
    age = plyr::mapvalues(age, age_map$acs_age, age_map$lic_age) %>% as.integer(),
    age_label = factor_age(age)
)
count(dat, age, age_label, age_acs_ordered, age_acs) %>% data.frame()
```

### Collapse over 7 age categories

- this is necessary since the ACS tracks many more age categories than we will track in the dashboard

```{r}
dat <- group_by(dat, year, county, sex, age) %>%
    summarise(value = sum(value)) %>%
    ungroup()
glimpse(dat)
```

### Join Fips

```{r}
dat <- mutate(dat, year = as.integer(year), sex = as.integer(sex)) %>%
    left_join(fips_county, by = "county")
```

### Pop by County

- Summarizes yearly values for total population by county
- Check some columns for consistency
    + pct_sd - will probably be less than 10% or so
    + n values (year, total_county) should be the same for all counties
    + pct_diff (last year versus mean) - probably will be within 10% or so

- Could also compare to wikipedia: For example,
    + https://en.wikipedia.org/wiki/List_of_counties_in_Georgia_(U.S._state)

```{r}
x <- count(dat, county) %>% rename(n_total_county = n) 
group_by(dat, county, year) %>%
    summarise(value = sum(value)) %>%
    summarise(min = round(min(value), 0), mean = round(mean(value), 0), 
              max = round(max(value), 0),  sd = round(sd(value), 0), 
              pct_sd = round(sd / mean * 100, 3), n_year = n()) %>% 
    left_join(x) %>%
    left_join(select(dat_total, county, acs_last_year = value)) %>%
    mutate(pct_diff = round(abs(acs_last_year - mean) / mean * 100, 2)) %>%
    DT::datatable()
```

## Write to SQLite

```{r}
pop_county <- select(dat, year, fips, sex, age, pop = value) %>%
    data.frame()
glimpse(pop_county)
glimpse(fips_county)
```

```{r}
# write to sqlite database
if (!params$test) {
    con <- dbConnect(SQLite(), dbname = params$db_file)
    
    # write tables (overwrite if this table already exists)
    if ("pop_county" %in% dbListTables(con)) dbRemoveTable(con, "pop_county")
    dbWriteTable(con, "pop_county", pop_county)
    
    if ("fips_county" %in% dbListTables(con)) dbRemoveTable(con, "fips_county")
    dbWriteTable(con, "fips_county", fips_county)
    
    dbDisconnect(con)
}
```

```{r}
sessionInfo()
```
